# 第十二章 模块

本章将集中介绍python模块和如何把数据从模块中导入到编程环境中.**模块是用来组织python代码的方法,而包则是用来组织模块的**.

## 什么是模块

把其他模块中的属性附加到你的模块中的操作叫做导入(import).那些自我包含并且有组织的代码片段就是模块.

## 模块和文件

一个文件被看作是一个独立模块,一个模块也可以被看作是一个文件.模块的文件名就是模块的名字加上扩展名.py

### 模块名称空间

一个名称空间就是一个从名称到对象的关系映射集合.每个模块都定义了子集的唯一的名称空间.通过句点属性标识指定了各自的名称空间----防止了名称冲突的发生.

### 搜索路径和路径搜索

模块的导入需要一个叫做"路径搜索"的过程.**即在文件系统"预定义区域"中查找被导入的模块对应的py文件**.这些预定义区域只不过是你在python搜索路径的集合.**路径搜索和搜索路径是两个不同的概念,前者是指查找某个文件的操作,后者是去查找一组目录**.

```python
import xxx
'''
ImportError                               Traceback (most recent call last)
<ipython-input-1-03794a928722> in <module>()
----> 1 import xxx

ImportError: No module named xxx
'''
```

上面语句中解释器高数你它无法访问请求的模块,然后报错,原因:可能是模块不在搜索路径里,从而导致了路径搜索失败.

**默认搜索路径是在编译或者安装时指定的.但是它也可以通过以下方式修改:**

- 设置环境变量PYTHONPATH,此变量可以通过sys.path来进行访问.通过操作sys.path来添加新的搜索路径.sys.path.append()

**使用sys.modules可以找到当前导入了哪些模块和它们来自什么地方**.

## 名称空间

名称空间是名称(标识符)到对象的映射.**向名称空间添加名称的操作过程涉及绑定标识符到指定对象的操作(以及给该对象的引用计数加1)**.改变一个名字的绑定叫做重新绑定,删除一个名字叫做解除绑定.

python程序在执行期间有两个或三个活动的名称空间.这三个名称空间分别是局部名称空间,全局名称空间和内建名称空间.但局部名称空间在执行期间是不断变化的,所以我们说"两个或三个".从名称空间中访问这些名字依赖于它们的加载顺序,或是系统加载这些名称空间的顺序.

**python解释器首先加载内建名称空间.它由\_\_builtins\_\_模块中的名字构成.随后加载执行模块的全局名称空间,它会在模块开始执行后变为活动名称空间.**这样我们就有了两个活动的名称空间.

### 核心笔记:_\_builtins\_\_和\_\_builtin\_\_

- \_\_builtins\_\_模块包含内建名称空间中内建名字的集合.包含\_\_builtin\_\_的所有名字
- \_\_builtin\_\_模块

> 我们可以通过globals()和locals()内建函数判断出某一名字属于哪个名称空间.

### 名称空间与变量作用域比较

名称空间是纯粹意义上的名字和对象间的映射关系,而作用域还指出了从用户代码的哪些物理位置可以访问到这些名字.

### 名称查找,确定作用域,覆盖

访问一个属性时,解释器必须在三个名称空间中的一个找到它.首先从局部名称空间开始,如果没有找到,解释器将继续查找全局名称空间,如果也失败了,它将在内建名称空间里查找.如果最后的尝试也失败了,会引发NameError错误.

### 无限制的名称空间

python有一个有用的特性在于你可以在任何需要放置数据的地方获得一个名称空间.比如你可以在任何时候给函数添加属性:

```python
def foo():
    pass
foo.__doc__ = 'Oops,forgot to add doc str above!'
foo.version = 0.2
```

## 导入模块

### import语句

语法如下:

```python
import module1[,module2[,...,moduleN]]
```

### 核心风格:import语句的模块顺序

python模块的导入顺序:

- python标准库模块
- python第三方模块
- 应用程序自定义模块

如果在一个模块的顶层导入,那么它的作用域就是全局的;如果在函数中导入,那么它的作用域是局部的.

如果模块是被第一次导入,它将被加载并执行.

### from-import语句

你可以在你的模块里导入指定的模块属性.也就是把指定名称导入到当前作用域.使用from-import语句可以实现我们的目的,它的语法是:

```python
from module import name1[,name2[,...,nameN]]
```

### 扩展的import语句(as)

使用举例如下:

```python
import Tkinter as tk
from cgi import FieldStorage as form
```

## 模块导入的特性

### 载入时执行模块

加载模块会导致这个模块被"执行".也就是被导入模块的顶层代码将直接被执行.**这通常包括设定全局变量以及类和函数的声明.如果有检查\_\_name\_\_的操作,那么它也会被执行.**

### 导入(import)和加载(load)

**一个模块只被加载一次,无论它被导入多少次.**

### 导入到当前名称空间的名称

调用from-import可以把名字导入当前的名称空间里去.

### 核心风格:限制使用 "from module import"

在实践中,我们认为"from module import"不是良好的编程风格,因为它"污染"当前名称空间,而且很可能覆盖当前名称空间中现有的名字;只有两种场合下建议使用此语法:

- 目标模块中的属性非常多,反复键入模块名很不方便
- 另一个场合是在交互解释器下,因为这样可以减少输入次数

### 关于\_\_future\_\_

使用from-import语句导入新特性,用户可以尝试一下新特性或特性变化.语法为:

from \_\_future\_\_ import new_feature

只import _\_future\_\_不会有任何变化,所以这是被禁止的.

### 从zip文件中导入模块

python加入了从ZIP归档文件导入模块的功能.如果你的搜索路径中存在一个包含python模块的zip文件,导入时会把zip文件作为目录处理,在文件中搜索模块.

如果要导入一个zip文件只包含.py文件,那么python不会为其添加对应的.pyc文件,这意味着导入速度会相对慢一些.

### "新的"导入钩子

导入zip归档文件这一特性是导入钩子(import hook,PEP302)的第一个使用者.**之前实现自定义导入器只能是使用一些很古老的模块,并不会简化创建导入器**.

另一个解决方法是覆盖\_\_import\_\_(),但是这需要重新实现整个导入机制.

python2.3引入的导入钩子,使你只需要编写可调用的import类,然后通过sys模块"注册"(或者叫"安装")它.

实现原理为:需要查找器和载入器.这两个类的实例接受一个参数(模块或包的全名称).查找器实例负责查找模块,找到了,就返回一个载入器对象.查找器可以接受一个路径用以查找子包(subpackage).载入器会把模块载入到内存.完成之后,返回模块.

> 这些实例被加入到sys.path_hooks.sys.path_importer_cache只是用来保存这些实例,这样就只需要访问path_hooks一次.最后,sys.meta_path用来保存一列需要在查询sys.path之前访问的实例.这些是为那些已经知道位置而不需要查找的模块准备的.mata-path已经有了指定模块或包的载入器对象的读取.

## 模块内建函数

### \_\_import\_\_()

它作为实际上导入模块的函数,这意味着import语句调用\_\_import\_\_()函数完成它的工作.提供这个函数是为了让有特殊需要的用户覆盖它,**实现自定义的导入算法**.

\_\_import\_\_()语法是:

```python
__import__(module_name[,globals[,locals[,fromlist]]])
```

module_name变量是要导入模块的名称,globals是包含当前全局符号表的名字和字典,locals是包含局部符号表的名字和字典,fromlist是一个使用from-import语句所导入符号的列表.

globals,locals和fromlist参数是可选的.默认分别为globals(),locals()和[].

import sys语句:

```python
sys = __import__('sys')
```

### globals()和locals()

globals()和locals()内建函数分别返回调用者全局和局部名称空间的字典.在一个函数内部,局部名称空间代表在函数执行时候定义的所有名字,locals()函数返回的就是包含这些名字的字典.globals()会返回函数可访问的全局名字.

```python
def foo():
    print '\ncalling foo()...'
    aString = 'bar'
    anInt = 42
    print "foo()'s globals:",globals().keys()
    print "foo()'s locals:",locals().keys()
    
print "__main__'s globals:",globals().keys()
print '-'*40
print "__main__'s locals:",locals().keys()
print '-'*40
foo()
'''
__main__'s globals: ['_dh', '__', '_i', 'quit', '__builtins__', '_ih', '__builtin__', '__name__', '___', '_', '_sh', '_i3', '_i2', '_i1', '__doc__', '_iii', 'exit', 'get_ipython', '_ii', 'In', 'foo', '_oh', 'Out']
----------------------------------------
__main__'s locals: ['_dh', '__', '_i', 'quit', '__builtins__', '_ih', '__builtin__', '__name__', '___', '_', '_sh', '_i3', '_i2', '_i1', '__doc__', '_iii', 'exit', 'get_ipython', '_ii', 'In', 'foo', '_oh', 'Out']
----------------------------------------

calling foo()...
foo()'s globals: ['_dh', '__', '_i', 'quit', '__builtins__', '_ih', '__builtin__', '__name__', '___', '_', '_sh', '_i3', '_i2', '_i1', '__doc__', '_iii', 'exit', 'get_ipython', '_ii', 'In', 'foo', '_oh', 'Out']
foo()'s locals: ['anInt', 'aString']
'''
```

### reload()

reload()内建函数可以重新导入一个已经导入的模块.语法如下:

```python
reload(module)
```

reload()内建函数的调用前提是:

- 模块必须全部导入,而不是使用from-import语句导入
- 参数必须是模块自身而不是模块名的字符串

reload()内建函数在重载模块的时候,模块中的代码也会被执行,相当于模块第一次导入.

## 包

**包是一个有层次的文件目录结构**,它定义了一个由模块和子包组成的python应用程序执行环境.它用来解决一下问题:

- 为平坦的名称空间加入有层次的组织结构
- 允许程序员把有联系的模块组合到一起
- 允许分发者使用目录结构而不是一大堆混乱的文件
- 帮助解决有冲突的模块名称

与类和模块相同,包也使用句点属性标识来访问它们的元素.

### 目录结构

目录中有很多的\_\_init\_\_.py文件,这些是初始化模块,from-import语句导入子包时需要用到它.如果没有用到,它们可以是空文件.如果在包目录中没有加入_\_init\_\_.py文件,将会导致一个ImportWarning信息.

### 使用from-import导入包

包同样支持from-import all语句:

```python
from package.module import *
```

这样的语句会导入哪些文件取决于操作系统的文件系统.**在\_\_init\_\_.py中加入\_\_all\_\_变量,该变量包含执行这样的语句时应该导入的模块的名字,它由一个模块名字字符串列表组成**.

**1.绝对导入**

**2.相对导入**

## 模块的其他特性

### 自动载入的模块

python解释器在标准模式下启动时,一些模块会被解释器自动导入,用于系统相关操作.

### 阻止属性导入

如果你不想让某个模块属性被"from module import *"导入,可以给不想被导入的属性名称加上一个下划线(_).不过,如果使用import module或者显示的导入该属性from module import _bar,或者 import module.\_bar,这个隐藏数据的方法就不起作用了.

### 不区分大小的导入

通过设置PYTHONCASEOK环境变量来开启不区分大小写的导入特性.

### 导入循环





