# 第九章 文件和输入输出

本章将深入介绍python文件处理和相关输入输出能力。我们将介绍文件对象(它的内建函数、内建方法和属性)、标准文件，同时讨论文件系统的访问方法、文件执行，最后简洁的介绍持久存储和标准库中与文件有关的模块。

## 文件对象

文件对象可以用来访问**普通的磁盘文件**，也可以访问**任何其他类型抽象层面上的"文件"**，一旦设置了合适的钩子，你就可以访问**具有文件类型接口的其他对象**。

内建函数open返回一个文件对象，对该文件进行后续相关的操作都要用到它。还有大量的函数也会返回文件对象或是类文件(file-like)对象。**进行这种抽象处理的主要原因是许多的输入输出数据结构更趋向于使用通用的接口，这样就可以在程序行为和实现上保持一致性**。像unix那样把文件作为通信的底层架构接口。请记住，文件只是连续的字节序列。数据的传输经常会用到字节流，无论字节流是由单个字节还是大块数据组成。

## 文件内建函数(open(),file())

作为打开文件之门的“钥匙”，内建函数open()以及file()提供了初始化输入/输出(I/O)操作的通用接口。open内建函数成功打开文件后会**返回一个文件对象**，否则引发一个错误。当操作失败，python会产生一个IOError异常。内建函数open()的基本语法是：

file_object = open(file_name, access_mode='r', buffering=-1)

file_name是包含要打开的文件名字的字符串，它可以是相对路径或者绝对路径。可选变量access_mode也是一个字符串，代表文件打开的模式。另外一个可选参数buffering用于指示访问文件所采用的缓冲方式。其中0表示不缓冲，1表示只缓冲一行数据，任何其他大于1的值代表使用给定值作为缓冲区的大小。不提供该参数或者给定负值代表使用系统默认缓冲机制，既对任何类电报机(tty)设备使用行缓冲，其他设备使用正常缓冲。一般情况下使用系统默认方式即可。

| 文件模式 | 操作                                         |
| -------- | -------------------------------------------- |
| r        | 以读方式打开                                 |
| rU或U    | 以读方式打开，同时提供通用换行符支持(PEP278) |
| w        | 以写方式打开(必要时清空)                     |
| a        | 以追加模式打开(从EOF开始，必要时创建新文件)  |
| r+       | 以读写模式打开                               |
| w+       | 以读写模式打开(参见w)                        |
| a+       | 以读写模式打开(参见a)                        |
| rb       | 以二进制读模式打开                           |
| wb       | 以二进制写模式打开(参见w)                    |
| ab       | 以二进制追加模式打开(参见a)                  |
| rb+      | 以二进制读写模式打开(参见r+)                 |
| wb+      | 以二进制读写模式打开(参见w+)                 |
| ab+      | 以二进制读写模式打开(参见a+)                 |

### 工厂函数file()

open()和file()函数具有相同功能，可以任意替换。你所看到任何使用open()的地方，都可以使用file()替换它。一般来说，我们建议使用open函数来读写文件，在你想说明你在处理文件对象时使用file()，例如if instance(f,file)。

### 通用换行符支持(UNS)

不同平台用来表示行结束的符号是不同的。当你使用‘U’标志打开文件的时候，所有的行分隔符(或行结束符，无论它原来是什么)通过python的输入方法(例如read*())返回是都会被替换为换行符NEWLINE(\n).文件对象的newlines属性会记录它曾"看到的"文件的行结束符。

如果文件刚被打开，程序还没有遇到行结束符，那么文件的newlines为None。在第一行被读取后，它被设置为第一行的结束符。如果遇到其他类型的行结束符，文件的newlines会成为一个包含每种格式的元组。注意UNS只用于读取文本文件。没有对应的处理文件输出的方法。

## 文件内建方法

文件方法可以分为四类：输入、输出、文件内移动及杂项。

### 输入

read()方法用来直接读取字节到字符串中，最多读取给定数目个字节。如果没有给定size参数(默认值为-1)或者size为负，文件将被读至末尾。(可能被删除)

readline()方法读取打开文件的一行(读取下个行结束符之前的所有字节)。然后整行，包括行结束符，作为字符串返回。和read()相同，有一个可选参数size，默认为-1，代表读至行结束符。size参数非负时，如果size小于当前行的长度时，返回不完整行，而如果size大于当前行的长度时，直接返回当前行。

readlines()方法并不像其他两个输入方法一样返回一个字符串。它会读取所有行然后把它们作为一个字符串列表返回。可选参数sizhint代表返回的最大字节大小。如果它大于0，那么返回的所有行应该大约有sizhint字节(可能稍微大于这个数字，因为需要凑齐缓冲区大小)。

xreadlines对象(在xreadlines模块中找到)。调用file.xreadlines()等价于xreadlines.xreadlines(file)。xreadlines()不是一次性读取所有的行，而是每次读取一块，所以在用for循环时较少内存占用。**但是可以使用for eachLine in file替代它，因此xreadlines不建议使用，或弃用**。

### 输出

write()内建方法的功能与read()和readline()相反。它把含有文本数据或二进制数据块的字符串写入到文件中去。

writelines()方法是针对列表的操作，它接受一个字符串列表作为参数，将他们写入文件。行结束符并不会被自动加入，所以如果需要，你必须在调用writelines()前给每行结尾加上行结束符。

### 核心笔记：保留行分隔符

read(),readlines()在读取文件的时候，不会自动删除行结束符。同样的使用write(),writelines()不会自动加入行结束符。

### 文件内移动

seek()方法可以在文件中移动文件指针到不同的位置。offset字节代表相对于某个位置偏移量。位置的默认值为0代表从文件开头算起(即绝对偏移量)，1代表从当前位置算起，2代表从文件末尾算起。

text()方法是对seek()的补充；它告诉你当前文件指针在文件中的位置——从文件开始算起，单位为字节。

### 文件迭代

```python
for eachLine in f:
    pass
```

在这个循环中，eachLine代表文本文件的一行(包括末尾的行结束符)，你可以使用它做任何想做的事情。

另外我们也可以使用迭代器的next()方法，file.next()可以用来读取文件的下一行。和其他迭代器一样，python也会在所有行迭代完成后引发StopIteration异常。

### 其他

close()通过关闭文件来结束对它的访问。python垃圾收集机制也会在文件对象的引用技术降至0的时候自动关闭文件。**良好的编程习惯要求在重新赋另一个文件对象前关闭这个文件。如果你不显示的关闭文件，那么你可能丢失输出缓冲区的数据**。

fileno()方法返回打开文件的描述符。

调用flush()方法会直接把内部缓冲区中的数据立即写入文件，而不是被动的等待输出缓冲区被写入。isatty()是一个布尔内建函数，当文件是一个类tty设备时返回True，否则返回False。truncate()方法将文件截取到当前文件指针位置或者到给定size，以字节为单位。

### 核心笔记：行分隔符和其他文件系统的差异

操作系统间的差异之一是它们所支持的行分隔符不同。另一个不同是路径分隔符。

有助于跨平台开发的os模块属性：

| os模块属性 | 描述                             |
| ---------- | -------------------------------- |
| linesep    | 用于在文件中分隔行的字符串       |
| sep        | 用来分隔文件路径名的字符串       |
| pathsep    | 用于分隔文件路径的字符串         |
| curdir     | 当前工作目录的字符串名称         |
| pardir     | (当前工作目录的)父目录字符串名称 |

不管你使用的是什么平台，只要你导入了os模块，这些变量自动会被设置为正确的值，减少了你的麻烦。

## 文件内建属性

文件对象除了方法之外，还有一些数据属性。这些属性保存了文件对象相关的附加数据。

| 文件对象属性   | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| file.close()   | 表达文件已经关闭，否则为False                                |
| file.encoding  | 文件所使用的编码——当Unicode字符串被写入时，它们将自动使用file.encoding转换为字节字符串； |
| file.mode      | Access文件打开时使用的访问模式                               |
| file.name      | 文件名                                                       |
| file.newlines  | 未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，则为一个包含所有当前行所遇到的行结束符的列表 |
| file.softspace | 为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般用不到 |

## 标准文件

一般来说，只要你的程序一执行，你就可以访问3个标准文件。它们分别是标准输入(一般是键盘)、标准输出(到显示器的缓冲输出)和标准错误(到屏幕的非缓冲输出)

python中可以通过sys模块来访问这些文件的句柄。导入sys模块后，就可以使用sys.stdin,sys.stdout,sys.stderr访问。

记得sys.*是文件，所以你必须自己处理好换行符。

## 命令行参数

sys模块通过sys.argv属性提供了对命令行参数的访问。命令行参数是调用某个程序时除程序名以外的其他参数。

```python
#输出为argv.py文件
import sys
print "your entered",len(sys.argv),'arguments...'
print "they were: ", str(sys.argv)
```

执行文件argv.py 76 tales 86 hawk

python还提供了两个模块用来辅助处理命令行参数。其中一个(最原始的)是getopt模块，它更简单些，但是不是很精细。optparse模块提供了一个更强大的工具，而且它更面向对象。如果你只是用到一些简答的选项，我们推荐getopt，但如果你需要提供复杂的选项，那么请参阅optparse。

## 文件系统

对文件系统的访问大多通过python的os模块实现。该模块是python访问操作系统功能的主要接口。os模块实际上只是真正加载的模块的前端，而真正的那个模块明显要依赖与具体的操作系统。



os模块下的函数：

| 函数                 | 描述                                                    |
| -------------------- | ------------------------------------------------------- |
| mkfifo()/mknod()     | 创建命名管道、创建文件系统节点                          |
| remove()/unlink()    | 删除文件                                                |
| rename()/renames()   | 重命名文件                                              |
| *stat()              | 返回文件信息                                            |
| symlink()            | 创建符号链接                                            |
| utime()              | 更新时间戳                                              |
| tmpfile()            | 创建并打开('w+b')一个新的临时文件                       |
| walk()               | 生成一个目录树下的所有文件名                            |
| chdir()/fchdir()     | 改变当前工作目录/通过一个文件描述符改变当前工作目录     |
| chroot()             | 改变当前进行的根目录                                    |
| listdir()            | 列出指定目录的文件                                      |
| getcwd()/getcwdu()   | 返回当前工作目录/功能相同，但返回一个Unicode对象        |
| mkdir()/makedirs()   | 创建目录/创建多层目录                                   |
| rmdir()/removedirs() | 删除目录/删除多层目录                                   |
| access()             | 检验权限模式                                            |
| chmod()              | 改变权限模式                                            |
| chown()lchown()      | 改变owner和groupID/功能相同，但不会跟踪链接             |
| umask()              | 设置默认权限模式                                        |
| open()               | 底层的操作系统open                                      |
| read()/write()       | 根据文件描述符读取/写入数据                             |
| dup()/dup2()         | 复制文件描述符号/功能相同，但是是复制到另一个文件描述符 |
| makedev()            | 从major和minor设备号创建一个原始设备号                  |
| major()/minor()      | 从原始设备号获得major/minor设备号                       |

os.path模块中的路径名访问函数：

| 函数         | 描述                             |
| ------------ | -------------------------------- |
| basename()   | 去掉目录路径，返回文件名         |
| dirname()    | 去掉文件名，返回目录路径         |
| join()       | 将分离的各部分组合成一个路径名   |
| split()      | 返回(dirname(),basename())元组   |
| splitdrive() | 返回(drivename,pathname)元组     |
| splittext()  | 返回(filename,extension)元组     |
| getatime()   | 返回最近访问时间                 |
| getctime()   | 返回文件创建时间                 |
| getmtime()   | 返回最近文件修改时间             |
| getsize()    | 返回文件大小(以字节为单位)       |
| exists()     | 指定路径(文件或目录)是否存在     |
| isabs()      | 指定路径是否为绝对路径           |
| isdir()      | 指定路径是否存在且为一个目录     |
| isfile()     | 指定路径是否存在且为一个文件     |
| islink()     | 指定路径是否存在且为一个符号链接 |
| ismount()    | 指定路径是否存在且为一个挂载点   |
| samefile()   | 两个路径名是否指向同一个文件     |

### 核心模块：os和os.path

os和os.path模块提供了访问计算机文件系统的不同方法。

## 永久存储模块

### pickle和marshal模块

python提供了许多可以实现最小化永久性存储的模块。marshal和pickle可以用来转换并储存python对象。该过程将比基本类型复杂的对象转换为一个二进制数据集合，这样就可以把数据集合保存起来或通过网络发送，然后再重新把数据集合恢复原来的对象格式。**这个过程也被称为数据的扁平化、数据的序列化或者数据的顺序化**。

marshal,pickle模块本身并没有提供永久性存储的功能。因为它们没有为对象提供名称空间，也没有提供对永久性储存对象的并发写入访问。

marshal和pickle的区别在于marshal只能处理简单的python对象(数字、序列、映射以及代码对象)，而pickle还可以处理递归对象，被不同地方多次引用的对象，以及用户定义的类和实例。

### DBM风格的模块

python提供了DBM的多种实现：dbhash/bsddb/dbm/gdbm/dumbdbm等。如果不确定的话，最好使用anydbm模块。dumbdbm模块是功能最少的一个，在没有其他模块可用时，anydbm才会选择。

这些模块为用户的对象提供了一个命名空间。这些对象同时具备字典对象和文件对象的特点。不足之处在于它们只能存储字符串，不能对python对象进行序列化。

### shelve模块

shelve模块使用anydbm模块寻找合适的DBM模块，然后使用cPickle来完成储存转换过程。shelve模块允许对数据库文件进行并发的读访问但不允许共享读/写访问。

## 相关模块

| 模块            | 内容                                                  |
| --------------- | ----------------------------------------------------- |
| base64          | 提供二进制字符串和文本字符串间的编码、解码操作        |
| binascii        | 提供二进制和ASCII编码的二进制字符串间的编码、解码操作 |
| bz2             | 访问bz2格式的压缩文件                                 |
| csv             | 访问csv文件                                           |
| filecmp         | 用于比较目录和文件                                    |
| fileinput       | 提供多个文本文件的行迭代器                            |
| getopt/optparse | 提供命令行参数的解析、处理                            |
| glob/fnmatch    | 提供unix样式的通配符匹配的功能                        |
| gzip/zlib       | 读写GNU zip文件                                       |
| shutil          | 提供高级文件访问功能                                  |
| c/StringIO      | 对字符串对象提供类文件接口                            |
| tarfile         | 读写TAR归档文件，支持压缩文件                         |
| tempfile        | 创建一个临时文件                                      |
| uu              | uu格式的编码和解码                                    |
| zipfile         | 用于读取zip归档文件的工具                             |







