# 第三章 语句和语法

## 语句和语法

python语句中有一些基本规则和特殊字符：

- 井号#表示之后的字符为python的注释
- 换行\n是标准的行分隔符
- 反斜线\继续上一行
- 分号；将两个语句连接在一行中
- 冒号：将代码块的头和体分开
- 语句(代码块)用缩进块的方式体现
- 不同的缩进深度分隔不同的代码块
- python文件以模块的形式组织

### 注释

python注释语句从#字符开始，注释可以在一行的任何地方开始，解释器会忽略掉该行#之后的所有内容。

### 继续

一行过长的语句可以使用反斜杠\截成几行，如下所示：

```python
#check conditions
if (weather_is_hot == 1) and \
   (shark_warnings==0):
    send_goto_beach_mesg_to_pager()
```

有两种例外情况一个语句不使用反斜线也可以跨行。在使用闭合操作符时，单一语句可以跨多行，例如：在含有小括号、中括号、花括号、三引号包括下的字符串时可以多行书写。

```python
print '''hello world
good bye,hi there,this is a long message for you
'''

go_surf_hello,get_a_than_while,boat_file_file_file_file,toll_money = (1,
                                                      'windsurfing',40.0,-2.00)
```

### 多个语句构成代码组

缩进相同的一组语句构成一个代码块，我们称之为代码组。首行以关键字开始，以冒号结束，该行之后的一行或多行代码构成代码组。我们将首行及后面的代码组称为一个子句（clause）。

### 代码组由不同的缩进分隔

> 核心风格：缩进4个空格宽度，避免使用制表符。

没有缩进的代码块是最高层次的，被称作脚本的‘主体’部分。使用缩进对齐这种方式组织代码，不但代码风格优雅，而且也大大提高了代码的可读性。而且它有效避免了“悬挂else”问题，和未写大括号的单一子句问题。

### 同一行书写多个语句

分号允许你将多个语句写在同一行上，语句之间用分号隔开，而这些语句也不能在这行开始一个新的代码块。

```python
import sys; x='foo'; sys.stdout.write(x+'\n')
```

> 注意：在同一行熵书写多个语句会大大降低代码的可读性，python虽然云溪但不提倡这么做。

### 模块

**每一个python脚本文件**都可以被当成一个模块。模块以**磁盘文件的形式**存在。当一个模块变得过大，并且驱动了太多功能的话，就应该考虑拆一些代码出来另外建一个模块。模块里的代码**可以是一段直接执行的脚本**，也可以是**一堆类似库函数的代码**，从而可以被别的模块导入(import)调用。

## 变量赋值

### 赋值操作符

注意，复制并不是直接将一个值赋给一个变量。在python语言中，**对象是通过引用传递的**。在赋值时，不管这个对象是新创建的,还是一个已经存在的，都是将该对象的引用赋值给变量。因此，**python赋值语句没有返回值**。

```python
x = 1
y = (x=x+1)
'''
会报错，因为赋值语句不是合法表达式
'''
#支持链式赋值
y = x = x+1
```

### 增量赋值

```python
x = x + 1
x += 1
x -= 1
x *= 1
x /= 1
x %= 1
x **= 1
x <<= 1
x >>= 1
x &= 1
x ^= 1
x |= 1
```

### 多重赋值

```python
#上面例子中，一个值为1的整型对象被创建，该对象的同一个引用被赋值给x、y和z。也就是将一个对象赋给了多个变量
x=y=z=1
```

### ”多元“赋值

另一种将多个变量同时赋值的方法我们称为多元赋值。因为采用这种方式赋值时，等号两边的对象都是元组。

## 标识符

标识符是计算机语言中允许作为名字的有效字符串集合。其中，有一部分是关键字，构成语言的标识符。另一部分为称作“内建”的标识符集合。

###合法的python标识符

python标识符字符规则和其他大部分用C编写的高级语言类似：

- 第一个字符必须是字母或下划线_
- 剩下的字符可以是字母和数字或下划线
- 大小写敏感

命名规则：

- 不能以数字开头
- 除了下划线，其他符号都不允许使用

###关键字

keyword模块中包含了一个关键字列表和一个iskeyword()函数。

| and     | as(python2.6)   | assert(python1.5) | break           |
| ------- | --------------- | ----------------- | --------------- |
| class   | continue        | def               | del             |
| elif    | else            | except            | exec            |
| finally | for             | from              | global          |
| if      | import          | in                | is              |
| lambda  | not             | or                | pass            |
| print   | raise           | return            | try             |
| while   | with(python2.6) | yield(python2.3)  | None(python2.4) |

**注意：关键字access从python1.4开始被废除**

###内建

除了关键字之外，python还有可以在任何一级代码使用的‘内建’的名字集合，这些名字可以由解释器设置或使用。虽然built-in不是关键字，但是应该把它当做‘系统保留字’，不做他用。但是有时候关键字可以被覆盖（重定义、替换）它们。python不支持重载标识符，因此任何时刻都只有一个名字绑定。

built-in是\_\_builtins\_\_模块的成员，把它们看成适用在任何一级python代码的全局变量。

###专用下划线标识符

python用下划线作为变量前缀和后缀指定特殊变量。这里对python中下划线的特殊用法做个总结：

- _xxx 不用from module import导入
- \_xxx\_ 系统定义名字
- _xxx 类中的私有变量名

>核心风格：避免使用下划线作为变量名的开始。因为下划线对解释器有特殊的意义。而且是内建标识符所使用的符号。一般来讲，变量名_xxx被看做是“私有的”，在模块或类外不可以使用。由于\_\_xxx\_\_对python来说有特殊含义，对于普通的变量应当避免这种命名风格。

## 基本风格指南

- 注释

  尽可能使注释简洁明了，并放在最合适的地方。这样注释便为每个人节省了时间和精力。记住，要确保注释的准确性。

- 文档

  python中提供了一个机制，可以通过\_\_doc\_\_特别变量，动态获取文档字串。在模块、类声明、或函数声明中**第一个*没有赋值的字符串可以用属性obj.\_\_doc\_\_来进行访问**，其中**obj是一个模块、类、或函数名字**。这在运行时也可以进行。

- 缩进

  推荐选用4个空格来进行缩进

- 选择标识符名称

  尽量为变量选择短而有意义的标识符。

- python风格指南

  Guido van Rossum 在多年前写下python代码风格指南。目前已经被至少3个PEP代替：

  - 7（C代码风格指南）
  - 8（python代码风格指南）
  - 257（文档字符串规范）

  pythonic指的是以python的方式去编写代码、组织逻辑和对象行为。更久以后，你才会真正理解它的含义。PEP20写的是python之禅，你可以通过import this来输出PEP20。

### 模块结构和布局

用模块来合理组织你的python代码是简单又自然的方法。你应该建立一种统一且容易阅读的结构。并将它应用到每一个文件中去。下面是一种非常合理的布局。

- 起始行
- 模块文档
- 模块导入
- 变量定义
- 类定义
- 函数定义
- 主程序

1. 起始行

   即#!/usr/bin/env python这样就可以输入脚本名字来执行脚本，无需直接调用解析器。

   同时可以指定编码#coding:utf8

2. 模块文档

   简要介绍模块的功能及重要全局变量的含义，通常使用三引号来表示字符串。模块外可通过module.\_\_doc\_\_访问这些内容。

   如：'''this is a test module'''

3. 模块导入

   导入当前模块的代码需要的所有模块；每个模块仅导入一次；函数内部的模块导入代码不会执行，除非该函数正在执行。

   如：import sys

4. 变量定义

   这里定义的变量为全局变量，本模块的所有函数都可直接使用。但是尽量减少使用全局变量，而使用局部变量。这样做不但使代码容易维护，而且还可以提高性能并节省内存。

   如：debug = True

5. 类定义语句

   所有的类都需要在这里定义。当模块被导入时class语句会被执行，类也就会被定义。类的文档变量是class.\_\_doc\_\_。

   ```python
   class FooClass(object):
       "Foo class"
       pass
   ```

6. 函数定义语句

   此处定义的函数可以通过module.function()在外部被访问到，当模块被导入时def语句会被执行，函数也就都会定义好，函数的文档变量是function.\_\_doc\_\_。

   ```python
   def test():
       "test function"
       foo = FooClass()
       if debug:
           print 'ran test()'
   ```

7. 主程序

   无论这个模块是被别的模块导入还是作为脚本直接执行，都会执行这部分代码。

   ```python
   if __name__ == '__main__':
       test()
   ```

> 核心风格：主程序调用main函数。大部分的python模块都是用于导入调用的，直接运行模块应该调用该模块的回归测试代码。
>
> 核心笔记：\_\_name\_\_指示模块应如何被加载。由于主程序代码无论模块是被导入还是被直接执行都会运行，我们必须直到模块如何决定运行方向。**一个应用程序可能需要导入另一个应用程序的一个模块，以便重用一些有用的代码，而不想运行被导入的应用程序**。因此python提供了一种在运行时检测该模块是被导入还是被直接执行的机制来解决这个问题。
>
> - 如果模块是被导入，\_\_name\_\_的值为模块名字
> - 如果模块是被直接执行，\_\_name\_\_的值为‘\_\_main\_\_’

### 在主程序中书写测试代码

测试代码仅当该文件被直接执行时运行。这些测试代码应该随着测试条件及测试结果的变更及时修改，每次代码更新都应该运行那些测试代码，以确认修改没有引发新问题。只要坚持这样做，你的代码就会足够强壮，更不用提验证和测试新特性和更新了。

在主程序中放置测试代码是测试模块的简单快捷的手段。python标准库中还提供了unittest模块，有时候它被称为PyUnit，是一个测试框架。如何使用unittest超出了本书的范围，不过当需要对一个大系统的组件进行正规系统的回归测试时，它就会派上用场。

## 内存管理

- 变量无需事先声明
- 变量无须指定类型
- 程序员不用关心内存管理
- 变量名会被“回收”
- del语句能够直接释放资源

### 变量定义

在python中，无须显式变量声明语句，变量在第一次被赋值时自动声明。和其他大多数语言一样，变量只有被创建和赋值后才能被使用。

### 动态类型

在python语言中，对象的**类型**和**内存占用**都是**运行时确定**的。尽管代码被编译成字节码，python仍然是一种解释性语言。在创建——也就是赋值时，**解释器会根据语法和右侧的操作数**来**决定**新对象的**类型**。在对象创建后，一个**该对象的引用**会**被赋值**给左侧的**变量**。

### 内存分配

为变量分配内存时，是在借用系统资源。在用完之后，应该释放借用的系统资源。python解释器承担了内存管理的复杂任务，这大大简化了应用程序的编写。（不需要手动释放内存）

### 引用计数

python使用引用计数这一简单技术来解决内存中的对象追踪问题。也就是说python内部记录着所有使用中的对象各有多少引用。当对象被创建时，就创建一个引用计数，当这个对象不再需要时，这个对象的引用计数变为0时，它被垃圾回收。

#### 增加引用计数

> 对象被创建并赋值给变量时，该对象的引用计数设置为1。当同一个对象又被赋值给其他变量时，或作为参数传递给函数、方法或类实例是，或者被复制为一个窗口对象的成员时，该对象的一个新的引用被创建，同时引用计数自动加1。

- 对象被创建 x = 3.14
- 另外的别名被创建 y = x
- 被作为参数传递给函数(新的本地引用)foobar(x)
- 或成为容器对象的一个元素myList=[123,x,'a']

#### 减少引用计数

> 当对象的引用被销毁是引用计数会减小。最明显的例子就是当引用离开其作用域时，所有局部变量都被自动销毁，对象的引用计数也就随机减少。当变量被赋值给另外一个对象时，原对象的引用计数自动减一。

- 一个本地引用离开了其作用范围(函数调用结束)
- 对象的别名被显示销毁 del y
- 对象被从一个窗口对象中移除 myList.remove(x)
- 窗口对象本身被销毁del myList

#### del语句

del语句会删除对象的一个引用。del obj1。

del y会产生两个结果：

- 从现有的名称空间中删除y
- x的引用计数减1

### 垃圾收集

不再使用的内存会被一种称为垃圾收集的机制释放。像上面说的，虽然解释器跟踪对象的引用计数为0的对象。它也负责检查那些**虽然引用计数大于0但也应该被销毁的对象**。

**循环引用**:当你有至少两个对象相互引用时，也就是说所有的引用都消失了，这些引用仍然存在，这说明仅靠引用计数是不够的。**python的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。当一个对象的引用计数变为0，解释器会暂停，释放掉这个对象以及仅有这个对象可到达的其他对象。作为引用计数的补充，垃圾收集器也会留心被分配的总量很大的（及未通过引用计数销毁的那些）对象。在这种情况下，解释器会暂停下来，试图清理所有未引用的循环**。