# 第四章 python对象

本章我们先了解什么是python对象，然后讨论最常用的内建类型，接下来我们讨论标准类型操作符和内建函数，之后给出对标准类型的不同的分类方式。这有助于我们更好地理解他们如何工作。

## python对象

python**使用对象模型来存储数据**。构造任何类型的值都是一个对象。所有的python对象都拥有三个特性：身份、类型和值。

**身份**：每一个对象都有一个唯一的身份标识自己，任何对象的身份可以**使用内建函数id()来得到**(**这个值可以被认为是该对象的内存地址**。你极少会用到这个值)。

**类型**：对象的类型**决定了该对象可以保存什么类型的值**，可以进行什么样的操作，以及遵循什么样的规则。你可以**使用内建函数type()查看**python对象的类型。(由于python中类型也是对象，所以type返回的是对象而不是简单的字符串)。

**值**：对象表示的数据项。

上面三个特性在对象创建的时候就被赋值了，除了值之外，其他两个特性都是只读的。对于新式类型和类，**对象的类型也是可以改变的(不过不推荐初学者这样做)**。

如果对象**支持更新操作**，那么它的值就可以改变，否则它的值也是只读的。**对象的值是否可以更改被称为对象的可改变性**。

## 标准类型

- 数字
- Integer 整型
- Boolean 布尔型
- Long Integer 长整形
- Floating point real number 浮点型
- Complex number 复数型
- String 字符串
- List 列表
- Tuple 元组
- Dictionary 字典

标准类型也称作"基本数据类型"，因为这些类型是python内建的基本数据类型。

## 其他内建类型

- 类型
- Null对象(None)
- 文件
- 集合/固定集合
- 函数/方法
- 模块
- 类

这些是当你做python开发时可能会用到的一些数据类型。

### 类型对象和type类型对象

你一定还记得，对象的一系列固有行为和特性(比如支持哪些运算，具有哪些方法)必须事先定义好。从这个角度看，类型正是保存这些信息的最佳位置。

通过调用type函数能够得到特定对象的类型信息：

```python
type(42)
'''<type 'int'>'''
```

上面语句的输出实际上是一个类型对象，碰巧它输出了一个字符串来告诉你它是个int型对象。

```python
type(type(42))
'''<type 'type'>'''
```

是的，所有类型对象的类型都是type，它也是所有python类型的根和所有python标准类的默认元类(metaclass)。

从现在起，类就是类型，实例就是对应类型的对象。

### None——python的null对象

python有一个特殊的类型，被称为Null对象或者NoneType，它**只有一个值**，那就是None。它**不支持任何运算也没有任何内建方法**。

None没有什么有用的属性，它的布尔值总是False。

> 核心笔记：布尔值。所有标准对象均可用于布尔测试，同类型的对象之间可以比较大小。每个对象天生具有布尔True或False值。空对象、值为0的任何数字或者Null对象布尔值都为False。

## 内部类型

- 代码
- 帧
- 跟踪记录
- 切片
- 省略
- Xrange(在python3中被弃用)

### 代码对象

**代码对象是编译过的python源代码片段，它是可执行对象**。

- 如何得到代码对象

  通过调用内建函数compile()可以得到代码对象。

- 如何运行代码对象

  被exec命令或eval内建函数来执行

**函数属性：**

代码对象本身不包含任何执行环境信息，它是用户自定义函数的核心，在被执行时动态获得上下文。**实际上代码对象是函数的一个属性**，一个函数除了有代码对象属性外，还有一些其他函数必须的属性，如函数名、文档字符串、默认参数、及全局命名空间等。

### 帧对象

帧对象表示python的执行栈帧。**帧对象包含python解释器在运行时所需要知道的所有信息**。

**帧对象的属性：**

- 指向上一帧的链接
- 正在被执行的代码对象
- 本地及全局名称空间字典
- 当前指令

每次函数调用产生一个新的帧，每一个帧对象都会相应创建一个C栈帧。用到帧对象的一个地方是跟踪记录对象。

### 跟踪记录对象

> 当异常发生时，如果没有被捕获和处理，解释器就会退出脚本运行。

当异常发生时，一个包含针对异常的栈跟踪信息的跟踪记录对象被创建。如果一个异常有自己的处理程序，处理程序就可以访问这个跟踪记录对象。

### 切片对象

使用python的扩展语法——切片语法时，会创建切片对象。扩展的切片语法允许对不同的索引切片操作，包括步进切片、多维切片和省略切片。

> 这里是二维数组切片：
>
> 多维切片语法：sequence[start1:end1,start2:end2] 
>
> 使用省略号：sequance[...,start1:end1] #目前只看到在numpy中使用省略号处理。

切片对象也可以通过slice函数来生成。步进切片允许利用第3个切片元素进行步进切片。

> 步进切片语法：sequance[start1:end1:step1]

### 省略对象

省略对象用于扩展切片语法中，起记号作用。这个对象在切片语法中表示省略号。类似Null对象None，省略对象由一个唯一的名字Ellipsis，**它的布尔值始终为True**。

### XRange对象

XRange为内建函数range的兄弟版本，用于需要节省内存使用或range无法完成的超大数据集场合。

## 标准类型操作符

### 对象值的比较

比较操作符用来判断同类型对象是否相等，所有的内建类型均支持比较运算，比较运算的返回值为True或False。

不同于其他语言，多个比较操作可以在同一行上进行，求值顺序为从左到右。

```python
3<4<7 #相当于3<4 and 4<7
4>3==3 #相当于4>3 and 3==3
4<3<5!=2<7 #相当于4<3 and 3<5 and 5!=2 and 2<7
```

### 对象身份比较

作为对值比较的补充，**python也支持对象本身的比较(用于判断是否是同一个对象)**。对象可以被赋值到另一个变量。因为每个变量都指向一个数据对象，只要任何一个引用使对象发生改变，该对象的其他引用也会随之改变。

```python
#指向同一个对象
foo1 = foo2 = 4.3
#指向同一个对象
foo1=4.3
foo2=foo1
#指向不同对象
foo1=4.3
foo2=4.3
#指向不同对象
foo1=4.3
foo2=1.3+3.0
```

> 虽然第三个例子中foo1和foo2的值一样，但事实上系统中保存的都是两个独立的对象。

python提供了is和is not操作符来测试两个变量是否指向同一个对象。a is b，等同于id(a) == id(b)



**注意：**你会注意到我们使用的是浮点型而不是整型。因为**整型对象和字符串对象是不可变对象**，所以python会很高效地缓存它们。这会造成我们认为python应该创建新对象时，它却没有创建新对象的假象。python仅缓存简单整型，因为它认为在python应用程序中这些小整型会经常被用到。在python2.7.13中，缓存范围为(-6,256)。

### 布尔类型

布尔逻辑操作符and,or和not都是python关键字，这些操作符的优先级按从高到低分别为not>and>or

## 标准类型内建函数

除了这些操作符，python提供了一些内建函数用于这些基本对象类型。

| 函数               | 功能                                                         |
| ------------------ | ------------------------------------------------------------ |
| cmp(obj1,obj2)     | 比较obj1和obj2，根据比较结构返回整型i：i==-1 if obj1<obj2; i==1 if obj1>obj2;i==0 if obj1==obj2 |
| repr(obj)或\`obj\` | 返回一个对象的字符串表示                                     |
| str(obj)           | 返回对象适合可读性好的字符串表示                             |
| type(obj)          | 得到一个对象的类型，并返回相应的type对象                     |

### type()

type()是内建函数，同时也是工厂函数。

type()接受一个对象作为参数，并返回它的类型。它的返回值是一个类型对象。

### cmp()

内建函数cmp()用于比较两个对象obj1和obj2.如果obj1小于obj2，则返回-1，如果obj1大于obj2则返回1，如果obj1等于obj2，则返回0。

### str()和repr()(及``操作符)

内建函数str()和repr()或反引号操作符(``)可以方便地以字符串的方式获取对象的内容、类型、数值属性等信息。str()函数得到的字符串可读性好，而**repr()函数得到的字符串通常可以用来重新获得该对象，通常情况下obj==eval(repr(obj))这个等式是成立的**。

```python
str(4.53-2j)
str(1)
```

**注意：并不是所有repr返回的字符串都能够用eval内建函数得到原来的对象。**

> 不建议使用``

### type()和isinstance()

python不支持方法或函数重载()，因此你必须自己保证调用的就是你想要的函数或对象。幸运的是，type内建函数可以帮助你确认这一点。

```python
# 原始的函数
def displayNumType(num):
    '''此函数与前面使用isinstance的函数完成一样的功能，但是时间复杂度比较大'''
    print num,'is',
    if type(num) == type(0):
        print 'an integer'
    elif type(num) == type(0L):
        print 'a long'
    elif type(num) == type(0.0):
        print 'a float'
    elif type(num) == type(0+0j):
        print 'a complex number'
    else:
        print 'not a number at all!'
        
#优化：减少函数调用的次数。
import types
def displayNumType(num):
    '''仔细研究代码，可以看到我们调用了两次type函数。通过减少type函数的调用来提高性能。
    通过以下方式来减少调用次数:导入types模块，将检测得到的类型与一个已知类型进行比较'''
    print num,' is',
    if type(num) == types.IntType:
        print 'an integer'
    elif type(num) == types.LongType:
        print 'a long'
    elif type(num) == types.FloatType:
        print 'a float'
    elif type(num) == types.ComplexType:
        print 'a complex number'
    else:
        print 'not a number at all!'
        
#优化：对象值比较VS对象身份比较
def displayNumType(num):
    '''
    因为进行对象值比较的过程是，先比较对象类型，然后比较对象的值。如果对象是不同的，
    那意味着原来的变量一定是不同类型的(因为每一个类型只有一个类型对象)，我们就没有必要去检查值了。
    '''
    print num,'is',
    if type(num) is types.IntType:
        print 'an integer'
    elif type(num) is types.LongType:
        print 'a long'
    elif type(num) is types.FloatType:
        print 'a float'
    elif type(num) is types.ComplexType:
        print 'a complex number'
    else:
        print 'not a number at all!'
        
#优化：减少查询次数
from types import IntType
from types import LongType
from types import FloatType
from types import ComplexType

def displayNumType(num):
    '''
    使用点方法来访问模块中的成员变量，会存在一次查询操作（解释器不得不首先查找types这个模块的名字，
    然后在该模块的字典中查找IntType）。而如果使用from-import直接导入该成员变量，那么就不再需要每次
    通过点操作来访问该成员变量，从而带来的过多的查询操作。
    '''
    print num,'is',
    if type(num) is IntType:
        print 'an integer'
    elif type(num) is LongType:
        print 'a long'
    elif type(num) is FloatType:
        print 'a float'
    elif type(num) is ComplexType:
        print 'a complex number'
    else:
        print 'not a number at all!'
        
#优化：惯例和代码风格
def displayNumType(num):
    '''
    在运行时环境使用isinstance函数和type函数
    使用isinstance，由于isinstance内建函数接受一个类型对象的元组作为参数，
    这样我们就不必像使用type函数那样写一堆if-else判断了。
    代码优化的版本为前面displayNumType函数的第一个实现版本。
    '''
    print num,'is',
    if isinstance(num, (int, long,float,complex)):
        print 'a number of type:', type(num).__name__
    else:
        print 'not a number at all!!'
```

## 类型工厂函数

- int(),long(),float(),complex()
- str(),unicode(),basestring()
- list(),tuple()
- type()
- dict()
- bool()
- set(),frozenset()
- object()
- classmethod()
- staticmethod()
- super()
- property()
- file()

## 标准类型的分类

标准类型也可称它们是python的“基本内建数据对象原始类型”：

- “基本”是指这些类型都是python提供的标准或核心类型
- “内建”是由于这些类型是python默认就提供的
- “数据”是因为它们用于一般数据存储
- “对象”是因为对象是数据和功能的默认抽象
- “原始”是因为这些类型提供的是最底层的粒度数据存储
- “类型”是因为它们就是数据类型

事实上，几个类型共享某一些特性，比如**功能的实现手段**；另一些类型则在**访问数据值方面**有一些共同之处。还有这些类型的**数据如何更新**，以及它们能**提供什么样的存储**。

下面我们通过3中不同的模型描述基本类型以及它们之间的相互关系，以及对它们进行分类。

### 存储模型

对类型分类的第一种方式：看看这种类型的对象**能保存多少个对象**。一个能保存单个字面对象的类型，我们称之为原子或标量存储；那些可容纳多个对象的类型，我们称之为容器存储(也称复合对象)。所有的python容器对象都能够容纳不同类型的对象。

| 分类          | python类型                               |
| ------------- | ---------------------------------------- |
| 标量/原子类型 | 数值(所有的数值类型)，字符串(全部是文字) |
| 容器类型      | 列表、元组、字典                         |

### 更新模型

另一种对标准类型进行分类的方式：对象创建成功之后，它的值是否可以进行更新。可变对象允许它们的值被更新，而不可变对象则不允许它们的值被更改。

| 分类       | python类型         |
| ---------- | ------------------ |
| 可变类型   | 列表、字典         |
| 不可变类型 | 数字、字符串、元组 |

### 访问模型

还有一种对基本类型分类的方式：根据访问我们存储的数据的方式对数据类型进行分类。在访问模型中共有三种访问方式：直接存取、顺序和映射。

**直接存取**：对非容器类型可以**直接访问**。所有的数值类型都归到这一类。

**序列类型**是指容器内的元素**按从0开始的索引顺序访问**。一次可以访问一个元素或多个元素，也就是大家所了解的切片。字符串、列表和元组都归到这一类。

**映射类型**类似序列的索引属性，不过它的索引并不使用顺序的数字偏移量取值，它的元素**无序存放**，**通过一个唯一的键来访问**，这就是映射类型，它容纳的是哈希键-值对的集合。

> 为什么对数据类型进行分类？
>
> 1. 因为python提供了高级的数据结构，我们需要将那些原始的类型和功能强大的扩展类型区分开来
> 2. 有助于搞清楚某种类型应该具有什么行为。
> 3. 一个优秀的工匠应该知道他或她的工具箱里都有那些宝贝

| 分类     | python类型         |
| -------- | ------------------ |
| 直接访问 | 数字               |
| 顺序访问 | 字符串、列表、元组 |
| 映射访问 | 字典               |

### 标准类型分类总表

| 数据类型 | 存储类型 | 更新类型 | 访问类型 |
| -------- | -------- | -------- | -------- |
| 数字     | 标量     | 不可更改 | 直接访问 |
| 字符串   | 标量     | 不可更改 | 顺序访问 |
| 列表     | 容器     | 可更改   | 顺序访问 |
| 元组     | 容器     | 不可更改 | 顺序访问 |
| 字典     | 容器     | 可更改   | 映射访问 |

## 不支持的类型

### char或byte

python中没有char或byte类型来保存单一字符或8位整型。你可以使用长度为1的字符串表示字符或8位整型。

### 指针

python替你管理内存，因此没有必要访问指针。其实在python中，一切皆为指针。

### int vs shot vs long

事实上python的整型实现等同于C语言的长整形。由于python的整型与长整形密切融合，用户几乎不需要担心什么。即便数值超出整型的表达范围，python会自动的返回一个长整型给你而不会报错。

### float VS double

python的浮点类型实际上是C语言的双精度浮点类型。python认为同时支持两种浮点类型的好处与支持两种浮点类型带来的开销不成比例。python还有一种十进制浮点型类型Decimal，不过你必须导入decimal模块才可以使用它。浮点型总是不精确的。Decimals则拥有任意的精度。在处理金钱这类确定的值时，decimal类型就很有用。